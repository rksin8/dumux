// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
// vi: set et ts=4 sw=4 sts=4:
/*****************************************************************************
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 3 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *****************************************************************************/
/*!
 * \file
 * \ingroup FEMDiscretization
 * \brief A simple test problem class for a poisson problem.
 */
#ifndef DUMUX_TEST_FEM_POISSON_PROBLEM_HH
#define DUMUX_TEST_FEM_POISSON_PROBLEM_HH

#include <cmath>

#include <dumux/common/math.hh>
#include <dumux/common/feproblem.hh>

namespace Dumux {

//! Forward declaration
template<class T, class SP, class PV>
class FEPoissonProblem;

//! Problem traits
//! \todo TODO Use generic implementation!?
template<class T, class S, class GG>
struct ProblemTraits< FEPoissonProblem<T, S, GG> >
{
    static constexpr int numEq = 1;

    using GridGeometry = GG;
    using Scalar = S;
    using PrimaryVariables = Dune::FieldVector<Scalar, numEq>;
    using NumEqVector = PrimaryVariables;
    using BoundaryTypes = Dumux::BoundaryTypes<numEq>;
};

/*!
 * \todo TODO: WHICH GROUP?
 * \ingroup todo
 * \brief Simple poisson problem discretized by the finite element method.
 * \tparam T The type used for tensors
 * \tparam S The type used for scalars
 * \tparam GG The grid geometry
 */
template<class T, class S, class GG>
class FEPoissonProblem : public FEProblem< FEPoissonProblem<T, S, GG> >
{
    using ThisType = FEPoissonProblem<T, S, GG>;
    using ParentType = FEProblem<ThisType>;

    using GridGeometry = GG;
    using Scalar = typename ProblemTraits<ThisType>::Scalar;
    using PrimaryVariables = typename ProblemTraits<ThisType>::PrimaryVariables;
    using NumEqVector = typename ProblemTraits<ThisType>::NumEqVector;
    using BoundaryTypes = typename ProblemTraits<ThisType>::BoundaryTypes;

    using GridView = typename GridGeometry::GridView;
    using Element = typename GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
    using FEElementGeometry = typename GridGeometry::LocalView;

    static constexpr int dim = GridView::dimension;
    static_assert(dim == 2, "This test only works in 2d");

    // tensor type (scalar or tensor) is defined in CMakeLists.txt
    using Tensor = TENSORTYPE;

public:

    //! The constructor
    FEPoissonProblem(std::shared_ptr<const GridGeometry> gridGeometry,
                     const std::string& paramGroup = "")
    : ParentType(gridGeometry, paramGroup)
    {
        name_ = getParamFromGroup<std::string>(paramGroup, "Problem.Name");
        setTensor_(paramGroup, tensor_);
    }

    //! return the tensor
    const Tensor& poissonTensor() const
    { return tensor_; }

    /*!
     * \name Problem parameters
     */
    // \{

    /*!
     * \brief The problem name. This is used as a prefix
     *        for files generated by the simulation.
     */
    std::string name() const
    { return name_; }

    // \}
    /*!
     * \name Boundary conditions
     */
    // \{

    /*!
     * \brief Specifies which kind of boundary condition should be
     *        used for which equation on a given boundary segment.
     * \param globalPos The position on the boundary
     */
    BoundaryTypes boundaryTypesAtPos(const GlobalPosition& globalPos) const
    {
        BoundaryTypes values;
        values.setAllDirichlet();
        return values;
    }

    /*!
     * \brief Evaluates the boundary conditions for a Dirichlet boundary segment.
     * \param globalPos The position on the boundary
     */
    PrimaryVariables dirichletAtPos(const GlobalPosition& globalPos) const
    { return exact(globalPos); }

    // \}

    /*!
     * \name Volume terms
     */
    // \{

    /*!
     * \brief Evaluates the source term at a given integration point.
     * \param element The grid element
     * \param feGeometry The local view on the grid geometry
     * \param elemSol The primary variables on the element
     * \param ipData The integration point data (shape values/gradients)
     * \param ipVars The primary/secondary variables evaluated at the integration point
     */
    NumEqVector sourceAtPos(const GlobalPosition& globalPos) const
    { return exactSource_(tensor_, globalPos); }

    // \}

    //! Returns the exact solution at a given position
    Scalar exact(const GlobalPosition& globalPos) const
    {
        const auto x = globalPos[0];
        const auto y = globalPos[1];

        using std::sin; using std::cos;
        return sin(x)*cos(y);
    }

private:
    Scalar exactSource_(const Scalar& tensor, const GlobalPosition& globalPos) const
    {
        const auto x = globalPos[0];
        const auto y = globalPos[1];

        using std::sin; using std::cos;
        return -2.0*tensor*sin(x)*cos(y);
    }

    Scalar exactSource_(const Dune::FieldMatrix<Scalar, dim, dim>& tensor,
                        const GlobalPosition& globalPos) const
    {
        const auto x = globalPos[0];
        const auto y = globalPos[1];

        using std::sin; using std::cos;
        return -tensor[0][0]*sin(x)*cos(y) - tensor[0][1]*cos(x)*sin(y)
               -tensor[1][0]*sin(x)*cos(y) - tensor[1][1]*sin(x)*cos(y);
    }

    //! set a scalar poisson tensor
    template<class Scalar>
    void setTensor_(const std::string& paramGroup, Scalar& tensor)
    {
        tensor = getParamFromGroup<Scalar>(paramGroup, "SpatialParams.TensorValue");
    }

    //! set a scalar poisson tensor
    template<class Scalar, int dim>
    void setTensor_(const std::string& paramGroup, Dune::FieldMatrix<Scalar, dim, dim>& tensor)
    {
        auto t = getParamFromGroup<Scalar>(paramGroup, "SpatialParams.TensorValue");
        auto r = getParamFromGroup<Scalar>(paramGroup, "SpatialParams.TensorAnisotropyRatio");
        auto phi = getParamFromGroup<Scalar>(paramGroup, "SpatialParams.TensorAngle");
        DUNE_THROW(Dune::NotImplemented, "Tensor parse from input file");
    }

    std::string name_;
    Tensor tensor_;
};

} // end namespace Dumux

#endif
