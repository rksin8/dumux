// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
// vi: set et ts=4 sw=4 sts=4:
/*****************************************************************************
 *   See the file COPYING for full copying permissions.                      *
 *                                                                           *
 *   This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation, either version 3 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 *****************************************************************************/
/*!
 * \file
 * \ingroup FEMDiscretization
 * \brief A simple test problem class for an algebraic problem.
 */
#ifndef DUMUX_TEST_FEM_ALGEBRAIC_PROBLEM_HH
#define DUMUX_TEST_FEM_ALGEBRAIC_PROBLEM_HH

#include <cmath>

#include <dumux/common/math.hh>
#include <dumux/common/feproblem.hh>

namespace Dumux {

//! Forward declaration
template<class SP, class PV>
class FEAlgebraicProblem;

//! Problem traits
//! \todo TODO Use generic implementation!?
template<class S, class GG>
struct ProblemTraits< FEAlgebraicProblem<S, GG> >
{
    static constexpr int numEq = 1;

    using GridGeometry = GG;
    using Scalar = S;
    using PrimaryVariables = Dune::FieldVector<Scalar, numEq>;
    using NumEqVector = PrimaryVariables;
    using BoundaryTypes = Dumux::BoundaryTypes<numEq>;
};

/*!
 * \todo TODO: WHICH GROUP?
 * \ingroup todo
 * \brief Simple poisson problem discretized by the finite element method.
 * \tparam S The type used for scalars
 * \tparam GG The grid geometry
 */
template<class S, class GG>
class FEAlgebraicProblem : public FEProblem< FEAlgebraicProblem<S, GG> >
{
    using ThisType = FEAlgebraicProblem<S, GG>;
    using ParentType = FEProblem<ThisType>;

    using GridGeometry = GG;
    using Scalar = typename ProblemTraits<ThisType>::Scalar;
    using PrimaryVariables = typename ProblemTraits<ThisType>::PrimaryVariables;
    using NumEqVector = typename ProblemTraits<ThisType>::NumEqVector;
    using BoundaryTypes = typename ProblemTraits<ThisType>::BoundaryTypes;

    using GridView = typename GridGeometry::GridView;
    using Element = typename GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
    using FEElementGeometry = typename GridGeometry::LocalView;
    using TimeLevel = Dumux::TimeLevel<Scalar>;

public:

    //! The constructor
    FEAlgebraicProblem(std::shared_ptr<const GridGeometry> gridGeometry,
                     const std::string& paramGroup = "")
    : ParentType(gridGeometry, paramGroup)
    {
        name_ = getParamFromGroup<std::string>(paramGroup, "Problem.Name");
    }

    /*!
     * \name Problem parameters
     */
    // \{

    /*!
     * \brief The problem name. This is used as a prefix
     *        for files generated by the simulation.
     */
    std::string name() const
    { return name_; }

    // \}
    /*!
     * \name Boundary conditions
     */
    // \{

    /*!
     * \brief Specifies which kind of boundary condition should be
     *        used for which equation on a given boundary segment.
     * \param globalPos The position on the boundary
     */
    BoundaryTypes boundaryTypesAtPos(const GlobalPosition& globalPos) const
    {
        BoundaryTypes values;
        values.setAllDirichlet();
        return values;
    }

    /*!
     * \brief Evaluate the Dirichlet boundary conditions at the given time for a boundary
     *        entity (sub entity of a grid element) that carries degrees of freedom.
     * \param element The grid element
     * \param subEntity The element's sub entity living on the boundary
     * \param timeLevel The time level
     * \note The values will be assigned to all dofs living on that sub entity
     */
    template<class SubEntity>
    PrimaryVariables dirichlet(const Element& element,
                               const SubEntity& subEntity,
                               const TimeLevel& timeLevel) const
    { return {exactSolution(timeLevel.currentTime())}; }

    // \}

    /*!
     * \name Volume terms
     */
    // \{

    /*!
     * \brief Evaluate the source term at a given integration point.
     * \note This is the overload for the case where the source term
     *       is potentially solution dependent and requires additional data.
     *
     * \param element The grid element
     * \param feGeometry The finite element geometry
     * \param gridVarsLocalView Local view on the grid variables
     * \param ipData Shape function values/gradients evaluated at an integration point
     * \param ipVars The primary/secondary variables evaluated at an integration point
     */
    template<class GridVarsLocalView, class IpData, class IpVariables>
    NumEqVector source(const Element& element,
                       const FEElementGeometry& feGeometry,
                       const GridVarsLocalView& gridVarsLocalView,
                       const IpData& ipData,
                       const IpVariables& ipVars) const
    {
        // we solve du/dt = e^t
        using std::exp;
        return {exp(gridVarsLocalView.gridVariables().timeLevel().currentTime())};
    }

    // \}

    //! Returns the exact solution at a time level
    Scalar exactSolution(Scalar time) const
    {
        using std::exp;
        return exp(time) - 1;
    }

private:
    std::string name_;
};

} // end namespace Dumux

#endif
